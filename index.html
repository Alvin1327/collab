<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pro 2-Player Shooter — Multiplayer</title>
<style>
:root{
  --bg1:#071322; --bg2:#061b2b; --panel:#081725;
  --muted:#9fb0c6; --accent:#ff7a4a;
  --p1:#4fc3ff; --p2:#ff6b8a; --heal:#8ef2b1;
}
html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
.container{max-width:1180px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:18px}
.card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 12px 48px rgba(2,6,23,0.6)}
.canvas-wrap{position:relative}
canvas{display:block;border-radius:10px;width:100%;height:680px;background:transparent}
.sidebar{height:680px;padding:12px;overflow:auto}
.h1{font-size:18px;margin:0}
.meta{color:var(--muted);font-size:13px;margin-top:6px}
.controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
.btn{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:var(--muted)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff8f6b);color:#071322;border:0}
.pill{display:inline-block;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:600}
.legend{display:flex;gap:8px;margin-top:12px}
.dot{width:12px;height:12px;border-radius:3px}
.footer{font-size:12px;color:var(--muted);margin-top:12px}
.badge{display:inline-block;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.35);font-weight:600}
.overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
.win-box{background:rgba(3,6,10,0.7);padding:28px;border-radius:12px;backdrop-filter: blur(4px);box-shadow:0 12px 40px rgba(0,0,0,0.6)}
.small{font-size:13px;color:var(--muted)}
@media(max-width:980px){.container{grid-template-columns:1fr;}.sidebar{height:auto}}
</style>
</head>
<body>
<div class="container">
  <div class="card canvas-wrap">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="h1">Pro 2-Player Cover Shooter</div>
        <div class="meta">WASD + Space (Player 1) • Arrow Keys + Enter (Player 2). Share link <code>#ROOMID</code> to play online (Socket.IO server required).</div>
      </div>
      <div class="badge" id="connBadge">Offline</div>
    </div>

    <div style="height:12px"></div>
    <canvas id="game" width="1200" height="680"></canvas>

    <div class="overlay" id="overlay" style="display:none;pointer-events:auto">
      <div class="win-box" id="winBox" style="text-align:center">
        <div id="winText" style="font-size:28px;font-weight:700"></div>
        <div class="small" style="margin-top:10px">Click <button class="btn" id="restartBtn">Restart</button> to play again</div>
      </div>
    </div>
  </div>

  <aside class="card sidebar">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div class="pill" id="scoreP1">P1: 0</div>
        <div style="margin-top:8px" class="pill" id="scoreP2">P2: 0</div>
      </div>
      <div>
        <button class="btn" id="respawnBtn">Respawn</button>
        <button class="btn primary" id="restartBtn2">Restart</button>
      </div>
    </div>

    <div class="section" style="margin-top:12px">
      <div class="small">Connection / Room:</div>
      <div style="margin-top:8px" class="small" id="roomLink">—</div>
      <div style="margin-top:6px" class="small" id="playerList">Players: —</div>
    </div>

    <div class="section" style="margin-top:12px">
      <div class="small">Legend</div>
      <div class="legend">
        <div style="display:flex;align-items:center;gap:8px"><div class="dot" style="background:var(--p1)"></div><div class="small">P1</div></div>
        <div style="display:flex;align-items:center;gap:8px"><div class="dot" style="background:var(--p2)"></div><div class="small">P2</div></div>
        <div style="display:flex;align-items:center;gap:8px"><div class="dot" style="background:#21343f"></div><div class="small">Cover</div></div>
        <div style="display:flex;align-items:center;gap:8px"><div class="dot" style="background:var(--heal)"></div><div class="small">Medkit</div></div>
      </div>
    </div>

    <div class="footer">60 FPS targeting • professional shaders & shadows • authoritative server (recommended for online)</div>
  </aside>
</div>

<!-- Try to load Socket.IO client. If not present, client will run local fallback. -->
<script src="/socket.io/socket.io.js"></script>
<script>
/* =========================
   Pro 2-Player Shooter Client
   - Single-file client
   - Uses Socket.IO when available for multiplayer rooms
   - Authoritative server provided separately in server.js below
   ========================= */

(() => {
  // Canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI nodes
  const connBadge = document.getElementById('connBadge');
  const roomLinkEl = document.getElementById('roomLink');
  const playerListEl = document.getElementById('playerList');
  const scoreP1El = document.getElementById('scoreP1');
  const scoreP2El = document.getElementById('scoreP2');
  const overlay = document.getElementById('overlay');
  const winBox = document.getElementById('winBox');
  const winText = document.getElementById('winText');
  const restartBtn = document.getElementById('restartBtn');
  const restartBtn2 = document.getElementById('restartBtn2');
  const respawnBtn = document.getElementById('respawnBtn');

  // URL room
  const ROOM = (location.hash && location.hash.slice(1)) || ('room-' + Math.random().toString(36).slice(2,8));
  roomLinkEl.textContent = location.origin + location.pathname + '#' + ROOM;

  // Game config
  const WIN_SCORE = 7;
  const PLAYER_SIZE = 44;
  const MAX_HP = 120;
  const FIRE_COOLDOWN = 220; // ms
  const BULLET_SPEED = 980; // px/sec
  const HEAL_AMOUNT = 48;
  const HEAL_SPAWN_INTERVAL = 10000;
  const RESPAWN_TIME = 1200;

  // High-DPI scaling for crisp 60fps look
  function pixelRatioSetup() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  pixelRatioSetup();

  // Objects
  const covers = [
    {x:220, y:240, w:280, h:30},
    {x:700, y:120, w:40, h:260},
    {x:440, y:420, w:320, h:40},
    {x:80, y:520, w:180, h:36},
    {x:980, y:300, w:160, h:36},
  ];
  let medkits = []; // {x,y,ttl,created,id}
  let bullets = []; // bullets local visualization for client
  let particles = []; // blood/heal particles

  // players container keyed by id
  const players = {}; // { id: {x,y,ang,score,hp,alive,color,lastShot,remoteInterp... } }
  let localId = null;
  let localPlayer = null; // reference to players[localId]
  let serverMode = false;
  let socket = null;

  // Input & controls
  const keys = {};
  let mouse = {x: W/2, y: H/2, down: false};
  window.addEventListener('keydown', (e) => { keys[e.code] = true; if (['Space','Enter'].includes(e.code)) e.preventDefault(); });
  window.addEventListener('keyup', (e) => { keys[e.code] = false; });
  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width) / (window.devicePixelRatio||1);
    mouse.y = (e.clientY - r.top) * (canvas.height / r.height) / (window.devicePixelRatio||1);
  });
  canvas.addEventListener('mousedown', () => mouse.down = true);
  window.addEventListener('mouseup', () => mouse.down = false);

  // Helper functions
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return Math.random()*(b-a)+a; }
  function rectOverlap(a,b){ return !(a.x+a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

  // Create procedural background texture (subtle noise)
  const bgCanvas = document.createElement('canvas');
  bgCanvas.width = 512; bgCanvas.height = 512;
  const bgCtx = bgCanvas.getContext('2d');
  for (let i=0;i<5000;i++){
    const x = Math.random()*512, y = Math.random()*512, a = Math.random()*0.08;
    bgCtx.fillStyle = `rgba(255,255,255,${a})`;
    bgCtx.fillRect(x,y,1,1);
  }
  const bgPattern = ctx.createPattern(bgCanvas, 'repeat');

  // spawn players initial (local fallback p1/p2)
  function spawnLocalDemo() {
    serverMode = false;
    localId = 'p1';
    players['p1'] = { id:'p1', x:200, y:160, ang:0, score:0, hp:MAX_HP, alive:true, color:getComputedStyle(document.documentElement).getPropertyValue('--p1').trim(), lastShot:0 };
    players['p2'] = { id:'p2', x:980, y:520, ang:Math.PI, score:0, hp:MAX_HP, alive:true, color:getComputedStyle(document.documentElement).getPropertyValue('--p2').trim(), lastShot:0 };
    localPlayer = players[localId];
    connBadge.textContent = 'Local';
    updateScores();
    updatePlayerList();
  }

  // SERVER: try connect socket.io; if fails, fallback to local demo
  function tryConnectServer() {
    if (typeof io === 'undefined') { spawnLocalDemo(); return; }
    try {
      socket = io(); // default served from same origin
    } catch(e) {
      spawnLocalDemo();
      return;
    }

    connBadge.textContent = 'Connecting...';
    socket.on('connect', () => {
      serverMode = true;
      localId = socket.id;
      connBadge.textContent = 'Server';
      socket.emit('joinRoom', ROOM);
    });

    socket.on('joined', (payload) => {
      // payload.players is map of players' initial state
      for (const id in payload.players) {
        ensurePlayer(id, payload.players[id]);
      }
      // if server didn't send local id content, create placeholder
      if (!players[localId]) ensurePlayer(localId, { x: rand(80, W-80), y: rand(80, H-80), score:0, hp:MAX_HP });
      localPlayer = players[localId];
      updateScores();
      updatePlayerList();
    });

    // updated authoritative snapshot from server
    socket.on('snapshot', (snap) => {
      // snap: { players: {id: {x,y,hp,score,alive}}, bullets:[{x,y,owner}], medkits: [...] }
      // update players (interpolate remote)
      for (const id in snap.players) {
        ensurePlayer(id, snap.players[id]);
        const s = snap.players[id];
        const p = players[id];
        // interpolate target pos for smoothing
        p.targetX = s.x; p.targetY = s.y; p.targetHP = s.hp; p.score = s.score; p.alive = s.alive;
        // set immediate if local
        if (id === localId) { p.x = s.x; p.y = s.y; p.hp = s.hp; p.alive = s.alive; }
      }
      // remove absent remotely
      for (const id in players) {
        if (!snap.players[id]) {
          delete players[id];
        }
      }
      // bullets & medkits used only for visuals
      bullets = snap.bullets || [];
      medkits = snap.medkits || [];
      updateScores();
      updatePlayerList();
    });

    socket.on('disconnect', () => {
      connBadge.textContent = 'Offline';
      // fallback local after short delay
      setTimeout(() => { if (!socket.connected) spawnLocalDemo(); }, 600);
    });

    // If server not responsive in 1.5s, fallback
    setTimeout(()=> { if (!serverMode) spawnLocalDemo(); }, 1500);
  }

  function ensurePlayer(id, data) {
    if (!players[id]) {
      players[id] = { id, x: data.x||rand(100, W-100), y: data.y||rand(100, H-100), ang:0, score:data.score||0, hp:data.hp||MAX_HP, alive: data.alive!==false, color: id==='p1' ? getComputedStyle(document.documentElement).getPropertyValue('--p1').trim() : getComputedStyle(document.documentElement).getPropertyValue('--p2').trim(), lastShot:0, targetX:null, targetY:null };
    }
  }

  // Input-driven local movement/shoot sending (either locally simulated or to server)
  function processInput(dt) {
    if (!localPlayer) return;
    // movement for p1 (WASD)
    if (localPlayer.id === 'p1' || !serverMode) {
      let dx=0, dy=0;
      if (keys['KeyW']) dy -= 1;
      if (keys['KeyS']) dy += 1;
      if (keys['KeyA']) dx -= 1;
      if (keys['KeyD']) dx += 1;
      if (dx||dy) {
        const len = Math.hypot(dx,dy)||1;
        const speed = 260;
        const nx = localPlayer.x + (dx/len)*speed*dt;
        const ny = localPlayer.y + (dy/len)*speed*dt;
        const box = { x: nx-PLAYER_SIZE/2, y: ny-PLAYER_SIZE/2, w: PLAYER_SIZE, h: PLAYER_SIZE };
        let blocked = false;
        for (const c of covers) if (rectOverlap(box,c)) { blocked=true; break; }
        if (!blocked) { localPlayer.x = clamp(nx, 20, W-20); localPlayer.y = clamp(ny, 20, H-20); }
      }
      localPlayer.ang = Math.atan2(mouse.y - localPlayer.y, mouse.x - localPlayer.x);
    }

    // movement for p2 (Arrow Keys)
    if (players['p2']) {
      const p2 = players['p2'];
      let dx=0, dy=0;
      if (keys['ArrowUp']) dy -= 1;
      if (keys['ArrowDown']) dy += 1;
      if (keys['ArrowLeft']) dx -= 1;
      if (keys['ArrowRight']) dx += 1;
      if (dx||dy) {
        const len = Math.hypot(dx,dy)||1;
        const speed = 240;
        const nx = p2.x + (dx/len)*speed*dt;
        const ny = p2.y + (dy/len)*speed*dt;
        const box = { x: nx-PLAYER_SIZE/2, y: ny-PLAYER_SIZE/2, w: PLAYER_SIZE, h: PLAYER_SIZE };
        let blocked = false;
        for (const c of covers) if (rectOverlap(box,c)) { blocked=true; break; }
        if (!blocked) { p2.x = clamp(nx, 20, W-20); p2.y = clamp(ny, 20, H-20); }
      }
      if (!serverMode) {
        // p2 faces p1 in local mode
        p2.ang = Math.atan2(players.p1.y - p2.y, players.p1.x - p2.x);
      }
    }

    // shooting: p1 -> Space, p2 -> Enter
    if (keys['Space']) { attemptShoot(localPlayer ? localPlayer.id : 'p1'); }
    if (keys['Enter']) { attemptShoot('p2'); }

    // send local state to server
    if (serverMode && socket && socket.connected && localPlayer) {
      socket.emit('cmd', { type:'input', room: ROOM, id: localPlayer.id, x: localPlayer.x, y: localPlayer.y, ang: localPlayer.ang });
    }
  }

  function attemptShoot(ownerId) {
    const p = players[ownerId];
    if (!p || !p.alive) return;
    const now = performance.now();
    if (now - (p.lastShot||0) < FIRE_COOLDOWN) return;
    p.lastShot = now;
    const ang = (ownerId==='p1') ? Math.atan2(mouse.y - p.y, mouse.x - p.x) : Math.atan2(players.p1.y - p.y, players.p1.x - p.x);
    // local visuals
    bullets.push({ x: p.x + Math.cos(ang)*(PLAYER_SIZE/2+8), y: p.y + Math.sin(ang)*(PLAYER_SIZE/2+8), vx: Math.cos(ang)*BULLET_SPEED, vy: Math.sin(ang)*BULLET_SPEED, owner: ownerId });
    // notify server authoritative
    if (serverMode && socket && socket.connected) {
      socket.emit('cmd', { type:'fire', room:ROOM, id: ownerId, x: p.x, y: p.y, ang });
    } else {
      // local simulated hit detection
      localSimulateFire(ownerId, ang);
    }
  }

  // Local simulated conservative hit detection (only for fallback)
  function localSimulateFire(ownerId, ang) {
    const startX = players[ownerId].x, startY = players[ownerId].y;
    // simulate bullet travel and test hits
    const step = 8;
    for (let t=0;t<1800;t+=step) {
      const bx = startX + Math.cos(ang) * (t/1000*BULLET_SPEED);
      const by = startY + Math.sin(ang) * (t/1000*BULLET_SPEED);
      // cover collision
      let blocked = false;
      for (const c of covers) { if (bx > c.x && bx < c.x+c.w && by > c.y && by < c.y+c.h) { blocked = true; break; } }
      if (blocked) break;
      // hit players
      for (const id in players) {
        if (id === ownerId) continue;
        const pl = players[id];
        if (!pl.alive) continue;
        const dx = bx - pl.x, dy = by - pl.y;
        if (dx*dx + dy*dy <= (PLAYER_SIZE*0.6)*(PLAYER_SIZE*0.6)) {
          // apply damage
          pl.hp -= 36;
          spawnBlood(bx, by, Math.atan2(Math.sin(ang), Math.cos(ang))+Math.PI);
          if (pl.hp <= 0) {
            pl.alive = false;
            players[ownerId].score += 1;
            // respawn victim
            setTimeout(() => {
              if (pl) { pl.hp = MAX_HP; pl.alive = true; pl.x = rand(80, W-80); pl.y = rand(80, H-80); }
            }, RESPAWN_TIME);
          }
          updateScores();
          return;
        }
      }
    }
  }

  // server authoritative calls may request respawn, restart etc
  function requestRespawn() {
    // local respawn
    if (localPlayer) { localPlayer.hp = MAX_HP; localPlayer.alive = true; }
    if (serverMode && socket && socket.connected) socket.emit('cmd', { type:'respawn', room:ROOM, id:localId });
  }

  // update visuals + physics for client side (smoothing for remote players)
  function clientTick(dt) {
    // Medkits spawn client-side for visuals only (server will drive real spawns when online)
    if (!serverMode && medkits.length < 2 && Math.random() < 0.007) {
      medkits.push({ id: 'm'+Date.now()+Math.random().toString(16).slice(2,6), x: rand(80,W-80), y: rand(80,H-80), ttl: 8000, created: performance.now() });
    }

    // bullets update
    for (let i = bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt; b.y += b.vy * dt;
      // out of bounds remove
      if (b.x < -30 || b.x > W+30 || b.y < -30 || b.y > H+30) { bullets.splice(i,1); continue; }
      // hit cover or players handled server-side; for local fallback, allowed to hit players via localSimulateFire
      // collide with covers visually
      for (const c of covers) {
        if (b.x > c.x && b.x < c.x+c.w && b.y > c.y && b.y < c.y+c.h) { bullets.splice(i,1); break; }
      }
    }

    // particles physics
    const now = performance.now();
    for (let i = particles.length-1; i>=0; i--) {
      const p = particles[i];
      const age = now - p.t0;
      if (age > p.life) { particles.splice(i,1); continue; }
      p.x += p.vx * dt; p.y += p.vy * dt; p.vy += (p.heal ? 400 : 900) * dt;
    }

    // remote players interpolation
    for (const id in players) {
      const p = players[id];
      if (p.targetX !== undefined && id !== localId) {
        // linear smoothing
        p.x += (p.targetX - p.x) * clamp(10*dt, 0, 1);
        p.y += (p.targetY - p.y) * clamp(10*dt, 0, 1);
        p.hp = p.targetHP !== undefined ? p.targetHP : p.hp;
      }
    }
  }

  // spawn blood particles
  function spawnBlood(x,y,dir,amt=14) {
    for (let i=0;i<amt;i++){
      particles.push({ x, y, vx: Math.cos(dir)*(rand(40,240)) + rand(-120,120), vy: Math.sin(dir)*(rand(40,240)) + rand(-120,120), t0: performance.now(), life: rand(500,1400), size: rand(2,4) });
    }
  }

  // spawn heal particles
  function spawnHeal(x,y,amt=8) {
    for (let i=0;i<amt;i++){
      particles.push({ x, y, vx: rand(-120,120), vy: rand(-320,-80), t0: performance.now(), life: 600+Math.random()*800, size: rand(2,4), heal:true });
    }
  }

  // UI updates
  function updateScores() {
    scoreP1El.textContent = `P1: ${players.p1 ? players.p1.score : 0}  HP:${players.p1 ? Math.max(0, Math.round(players.p1.hp)) : 0}`;
    scoreP2El.textContent = `P2: ${players.p2 ? players.p2.score : 0}  HP:${players.p2 ? Math.max(0, Math.round(players.p2.hp)) : 0}`;
  }
  function updatePlayerList() {
    const list = Object.keys(players).join(', ') || '—';
    playerListEl.textContent = 'Players: ' + list;
  }

  // Rendering: enhanced graphics with shadows & lighting
  function render() {
    // background gradient & pattern
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#081627';
    ctx.fillRect(0,0,W,H);

    // subtle vignette radial
    const grd = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)/3, W/2, H/2, Math.max(W,H));
    grd.addColorStop(0, 'rgba(255,255,255,0.02)');
    grd.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);

    // background glint pattern
    ctx.globalAlpha = 0.05;
    ctx.fillStyle = bgPattern;
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // simple dynamic light under players (soft)
    for (const id in players) {
      const p = players[id];
      const r = 80;
      const lingrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
      lingrad.addColorStop(0, id===localId ? 'rgba(80,180,255,0.08)' : 'rgba(255,110,140,0.06)');
      lingrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = lingrad;
      ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    }

    // draw covers with subtle bevel & shadow
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.7)';
    ctx.shadowBlur = 18;
    for (const c of covers) {
      // base
      roundedRect(ctx, c.x, c.y, c.w, c.h, 8);
      ctx.fillStyle = '#11262b';
      ctx.fill();
      // top highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.stroke();
      // inner texture
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = bgPattern;
      ctx.fillRect(c.x, c.y, c.w, c.h);
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    // medkits
    for (const m of medkits) {
      // gentle float
      const t = ((performance.now()/400) + (m.id||0)) % Math.PI*2;
      const oy = Math.sin(t)*4;
      ctx.save();
      ctx.translate(m.x, m.y+oy);
      // soft shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.ellipse(0, 18, 18, 8, 0, 0, Math.PI*2);
      ctx.fill();
      // box
      ctx.fillStyle = 'rgba(140,242,170,0.96)';
      roundedRect(ctx, -14, -14, 28, 28, 6);
      ctx.fill();
      ctx.fillStyle = '#041612';
      ctx.fillRect(-4, -8, 8, 16);
      ctx.fillRect(-8, -4, 16, 8);
      ctx.restore();
    }

    // bullets
    for (const b of bullets) {
      ctx.beginPath();
      ctx.fillStyle = b.owner === 'p1' ? '#ffd166' : '#ff8b94';
      // motion blur ellipse
      ctx.save();
      ctx.translate(b.x, b.y);
      const speed = Math.hypot(b.vx, b.vy);
      const len = clamp(speed/500, 1, 6);
      ctx.rotate(Math.atan2(b.vy, b.vx));
      ctx.fillRect(-2*len, -2, 4*len, 4);
      ctx.restore();
    }

    // players
    for (const id in players) {
      const p = players[id];
      // shadow
      ctx.beginPath();
      ctx.ellipse(p.x, p.y + PLAYER_SIZE/2 + 8, PLAYER_SIZE/1.6, PLAYER_SIZE/3, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fill();

      // body with rotation and highlight
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.ang || 0);
      // body base
      roundedRect(ctx, -PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE, 8);
      ctx.fillStyle = p.color || (id==='p1' ? getComputedStyle(document.documentElement).getPropertyValue('--p1').trim() : getComputedStyle(document.documentElement).getPropertyValue('--p2').trim());
      if (!p.alive) ctx.globalAlpha = 0.28;
      ctx.fill();
      // gun stub with subtle metallic gradient
      ctx.fillStyle = '#08161a';
      ctx.fillRect(6, -8, PLAYER_SIZE/1.7, 14);
      // rim light
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      roundedRect(ctx, -PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE, 8);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();

      // hp bar
      const hpPct = clamp(p.hp / MAX_HP, 0, 1);
      const barW = 92;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(p.x - barW/2, p.y - PLAYER_SIZE/2 - 16, barW, 9);
      ctx.fillStyle = id === 'p1' ? '#4fd1c5' : '#ff9fb0';
      ctx.fillRect(p.x - barW/2, p.y - PLAYER_SIZE/2 - 16, barW * hpPct, 9);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.strokeRect(p.x - barW/2, p.y - PLAYER_SIZE/2 - 16, barW, 9);

      // name & score
      ctx.fillStyle = '#dbe7f2';
      ctx.font = '12px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText((id==='p1' ? 'Player 1' : 'Player 2') + ' • ' + p.score, p.x, p.y + PLAYER_SIZE/2 + 18);
    }

    // particles
    for (const q of particles) {
      const age = performance.now() - q.t0;
      const t = age / q.life;
      ctx.globalAlpha = 1 - t;
      ctx.beginPath();
      ctx.fillStyle = q.heal ? 'rgba(140,242,170,0.95)' : '#ff4b4b';
      ctx.arc(q.x, q.y, q.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // HUD (top-left)
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(14, 14, 270, 48);
    ctx.fillStyle = '#cfe7f6';
    ctx.font = '14px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`P1: ${players.p1 ? players.p1.score : 0}  HP: ${players.p1 ? Math.max(0, Math.round(players.p1.hp)) : 0}`, 24, 36);
    ctx.fillText(`P2: ${players.p2 ? players.p2.score : 0}  HP: ${players.p2 ? Math.max(0, Math.round(players.p2.hp)) : 0}`, 160, 36);

    // winner overlay
    if (window.winner) {
      overlay.style.display = 'flex';
      winText.textContent = (window.winner === 'p1' ? 'PLAYER 1' : 'PLAYER 2') + ' WINS';
    } else {
      overlay.style.display = 'none';
    }
  }

  // Rounded rect helper
  function roundedRect(ctx,x,y,w,h,r){
    if (r===undefined) r=8;
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Update loop including server authoritative interactions
  let last = performance.now();
  window.winner = null;
  function frame(now) {
    const dt = Math.min(40, now - last) / 1000; // seconds
    last = now;
    // Input processing and local tick
    if (serverMode) {
      // In server mode, client sends inputs; server returns authoritative snapshots
      processInput(dt);
    } else {
      // local simulation for both players
      processInput(dt);
      clientTick(dt);
      // local authoritative collision detection for fallback: check bullet hits (simulate)
      handleLocalServerLogic(dt);
    }
    // Render
    render();
    requestAnimationFrame(frame);
  }

  // Process input (movement & shooting) — same as earlier but keeps localPlayer
  function processInput(dt) {
    if (!localPlayer) return;
    // movement P1
    if (keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD']) {
      const dx = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
      const dy = (keys['KeyS']?1:0) - (keys['KeyW']?1:0);
      if (dx || dy) {
        const len = Math.hypot(dx,dy)||1;
        const speed = 280;
        const nx = localPlayer.x + (dx/len)*speed*dt;
        const ny = localPlayer.y + (dy/len)*speed*dt;
        const box = {x:nx-PLAYER_SIZE/2, y:ny-PLAYER_SIZE/2, w:PLAYER_SIZE, h:PLAYER_SIZE};
        let blocked = false;
        for (const c of covers) if (rectOverlap(box,c)) { blocked=true; break; }
        if (!blocked) { localPlayer.x = clamp(nx,20,W-20); localPlayer.y = clamp(ny,20,H-20); }
      }
      localPlayer.ang = Math.atan2(mouse.y - localPlayer.y, mouse.x - localPlayer.x);
    }
    // p2 movement
    if (players.p2) {
      const p2 = players.p2;
      const dx = (keys['ArrowRight']?1:0) - (keys['ArrowLeft']?1:0);
      const dy = (keys['ArrowDown']?1:0) - (keys['ArrowUp']?1:0);
      if (dx || dy) {
        const len = Math.hypot(dx,dy)||1;
        const speed = 260;
        const nx = p2.x + (dx/len)*speed*dt;
        const ny = p2.y + (dy/len)*speed*dt;
        const box = {x:nx-PLAYER_SIZE/2, y:ny-PLAYER_SIZE/2, w:PLAYER_SIZE, h:PLAYER_SIZE};
        let blocked = false;
        for (const c of covers) if (rectOverlap(box,c)) { blocked=true; break; }
        if (!blocked) { p2.x = clamp(nx,20,W-20); p2.y = clamp(ny,20,H-20); }
      }
      if (!serverMode) p2.ang = Math.atan2(players.p1.y - p2.y, players.p1.x - p2.x);
    }

    // shooting
    if (keys['Space']) attemptShoot(localPlayer.id || 'p1');
    if (keys['Enter']) attemptShoot('p2');

    // send input to server if online
    if (serverMode && socket && socket.connected && localPlayer) {
      socket.emit('cmd', { type:'input', room: ROOM, id: localPlayer.id, x: localPlayer.x, y: localPlayer.y, ang: localPlayer.ang });
    }
  }

  // Local authoritative logic for fallback (simple): handle bullet travel & hits server-side logic style
  function handleLocalServerLogic(dt) {
    // bullets vector step handled in clientTick; we must check collision and scoring authoritative
    for (let i = bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      // check player hits
      for (const id in players) {
        if (id === b.owner) continue;
        const p = players[id];
        if (!p.alive) continue;
        const dx = b.x - p.x, dy = b.y - p.y;
        if (dx*dx + dy*dy <= (PLAYER_SIZE*0.6)*(PLAYER_SIZE*0.6)) {
          // hit
          p.hp -= 36;
          spawnBlood(b.x, b.y, Math.atan2(b.vy, b.vx)+Math.PI);
          bullets.splice(i,1);
          if (p.hp <= 0) {
            p.alive = false;
            players[b.owner].score += 1;
            updateScores();
            // respawn
            setTimeout(()=> { if (p) { p.hp = MAX_HP; p.alive = true; p.x = rand(80,W-80); p.y = rand(80,H-80); } }, RESPAWN_TIME);
            // winner?
            if (players[b.owner].score >= WIN_SCORE) {
              declareWinner(b.owner);
            }
          }
          break;
        }
      }
    }
    // medkit collection local
    const now = performance.now();
    for (let i = medkits.length-1; i>=0; i--) {
      const m = medkits[i];
      if (now - m.created > (m.ttl||8000)) { medkits.splice(i,1); continue; }
      for (const id in players) {
        const p = players[id];
        if (!p.alive) continue;
        if (Math.hypot(p.x - m.x, p.y - m.y) < PLAYER_SIZE) {
          p.hp = clamp(p.hp + HEAL_AMOUNT, 0, MAX_HP);
          spawnHeal(m.x, m.y);
          medkits.splice(i,1);
          break;
        }
      }
    }
  }

  // spawn medkit helper (server will handle real spawns when online)
  function spawnMedkitLocal() {
    const m = { id:'m'+Date.now()+Math.random().toString(16).slice(2,6), x: rand(80,W-80), y: rand(80,H-80), ttl: 9000, created: performance.now() };
    medkits.push(m);
  }

  // expose heal particle spawn
  function spawnHeal(x,y) { spawnHeal; for (let i=0;i<12;i++){ particles.push({ x, y, vx:rand(-160,160), vy:rand(-420,-80), t0:performance.now(), life:800+Math.random()*800, size:2+Math.random()*3, heal:true }); } }

  // Winner declaration
  function declareWinner(id) {
    window.winner = id;
    connBadge.textContent = 'Game Over';
    // subtle confetti particles
    for (let i=0;i<160;i++){
      particles.push({ x: W/2 + rand(-120,120), y: H/2 + rand(-40,40), vx: rand(-400,400), vy: rand(-600,-80), t0: performance.now(), life: 800+Math.random()*1200, size:2+Math.random()*4, heal:true });
    }
    overlay.style.display = 'flex';
    winText.textContent = (id==='p1' ? 'PLAYER 1 WINS' : 'PLAYER 2 WINS');
  }

  // Restart & respawn UI handlers
  restartBtn.addEventListener('click', ()=> { restartGame(true); });
  restartBtn2.addEventListener('click', ()=> { restartGame(true); });
  respawnBtn.addEventListener('click', requestRespawn);

  function restartGame(resetScores) {
    for (const id in players) {
      players[id].hp = MAX_HP; players[id].alive = true;
      players[id].x = id==='p1' ? 200 : 980;
      players[id].y = id==='p1' ? 160 : 520;
      if (resetScores) players[id].score = 0;
    }
    bullets = []; medkits = []; particles = []; window.winner = null; overlay.style.display = 'none';
    updateScores();
  }

  // Update scores UI
  function updateScores() {
    scoreP1El.textContent = `P1: ${players.p1 ? players.p1.score : 0}  HP:${players.p1 ? Math.max(0, Math.round(players.p1.hp)) : 0}`;
    scoreP2El.textContent = `P2: ${players.p2 ? players.p2.score : 0}  HP:${players.p2 ? Math.max(0, Math.round(players.p2.hp)) : 0}`;
  }

  // Try connect server
  tryConnectServer();

  // Spawn initial medkits locally on timer when in fallback
  setInterval(()=>{ if (!serverMode) spawnMedkitLocal(); }, 7500);

  // Main loop
  let lastTime = performance.now();
  function loop(t) {
    const dt = Math.min(40, t - lastTime) / 1000;
    lastTime = t;
    processInput(dt);
    clientTick(dt);
    // If using serverMode, interpolation of remote players handled in snapshot handler
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Utility: spawn blood wrapper
  function spawnBlood(x,y,dir) { for (let i=0;i<14;i++){ particles.push({ x, y, vx: Math.cos(dir)*(rand(40,220)) + rand(-140,140), vy: Math.sin(dir)*(rand(40,220)) + rand(-140,140), t0:performance.now(), life: 500+Math.random()*900, size: 2+Math.random()*3 }); } }

  // Set initial local demo if server not present
  setTimeout(()=>{ if (!serverMode && Object.keys(players).length === 0) spawnLocalDemo(); }, 200);

  // expose some methods for debugging
  window.__PRO_GAME = { players, bullets, medkits, particles, covers, ROOM, declareWinner };

})();
</script>
</body>
</html>
